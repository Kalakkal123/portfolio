<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CSS Terrain Generator (no WebGL)</title>
  <style>
    :root{
      --cols: 48;
      --rows: 32;
      --tile-size: 14px;
      --layer-spacing: 6; /* multiply height -> translateZ(px) */
      --max-height: 40; /* max FBM value mapped */
      --scene-rotate-x: 55deg;
      --scene-rotate-y: -10deg;
      --ambient: 0.8;
    }

    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{display:flex;gap:20px;padding:18px;background:linear-gradient(180deg,#0f172a,#071028);color:#eef;text-align:center}

    /* controls */
    .panel{width:360px;min-width:260px;background:rgba(255,255,255,0.03);padding:14px;border-radius:12px;box-shadow:0 6px 30px rgba(0,0,0,0.6)}
    .panel h2{margin:6px 0 12px;font-size:18px}
    .row{display:flex;gap:8px;margin:8px 0;align-items:center}
    label{font-size:13px;min-width:78px;text-align:left;color:#cfe}
    input[type=range]{flex:1}
    input[type=number], input[type=text]{width:100%;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{margin-top:8px;padding:8px 10px;border-radius:8px;border:0;background:#1f2937;color:#fff;cursor:pointer}

    /* scene */
    .stage{flex:1;display:flex;align-items:center;justify-content:center}
    .viewport{
      width:calc(var(--cols) * var(--tile-size));
      height:calc(var(--rows) * var(--tile-size));
      perspective:1000px;
      perspective-origin:50% 20%;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2));
      border-radius:12px; padding:14px;box-sizing:content-box;
    }

    .scene{
      width:100%;height:100%;transform-style:preserve-3d;transform:rotateX(var(--scene-rotate-x)) rotateY(var(--scene-rotate-y));
      position:relative; margin:auto;
    }

    .tile{
      position:absolute; width:var(--tile-size); height:var(--tile-size);
      transform-style:preserve-3d; backface-visibility:hidden; border-radius:2px;
      box-shadow:0 1px 0 rgba(0,0,0,0.2) inset, 0 4px 10px rgba(0,0,0,0.35);
      transition: transform 250ms linear, background-color 250ms linear;
      will-change:transform;
      display:block; overflow:hidden;
    }

    /* subtle top highlight using pseudo-element */
    .tile::after{
      content:'';position:absolute;inset:0;border-radius:2px;pointer-events:none;mix-blend-mode:overlay;opacity:0.45
    }

    /* helper UI */
    .small{font-size:12px;color:#bfe}
    .credits{position:fixed;left:18px;bottom:18px;color:#9fd;opacity:0.8}
  </style>
</head>
<body>
  <div class="panel">
    <h2>CSS Terrain Generator (no WebGL)</h2>

    <div class="row"><label>Seed</label><input id="seed" type="text" value="12345"></div>
    <div class="row"><label>Scale</label><input id="scale" type="range" min="4" max="120" value="24"><div style="width:48px;text-align:right" id="scaleVal">24</div></div>
    <div class="row"><label>Octaves</label><input id="octaves" type="range" min="1" max="6" value="4"><div style="width:28px;text-align:right" id="octVal">4</div></div>
    <div class="row"><label>Persistence</label><input id="persistence" type="range" min="0.1" max="1" step="0.05" value="0.5"><div style="width:36px;text-align:right" id="persVal">0.5</div></div>
    <div class="row"><label>Max height</label><input id="maxh" type="range" min="6" max="80" value="36"><div style="width:36px;text-align:right" id="maxhVal">36</div></div>
    <div class="row"><label>Cols Ã— Rows</label>
      <div style="display:flex;gap:6px;width:100%">
        <input id="cols" type="number" value="48" min="8" max="120"> 
        <input id="rows" type="number" value="32" min="8" max="80">
      </div>
    </div>
    <div style="display:flex;gap:8px">
      <button id="regen">Regenerate</button>
      <button id="randomize">Random seed</button>
      <button id="export">Export HTML</button>
    </div>
    <p class="small">Tip: rotate the scene (drag on the preview) or tweak <code>Scale</code> for big vs small features.</p>
  </div>

  <div class="stage">
    <div class="viewport">
      <div id="scene" class="scene"></div>
    </div>
  </div>

  <script>
    // ---------- Simple seeded noise (value noise + FBM) ----------
    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    function fade(t){ return t * t * (3 - 2 * t); }
    function lerp(a,b,t){ return a + (b-a) * t; }

    // Create a grid of random values with seeded RNG
    function makeValueGrid(seed, gx, gy){
      const rnd = mulberry32(hashString(seed));
      const grid = new Float32Array((gx+1)*(gy+1));
      for(let j=0;j<=gy;j++) for(let i=0;i<=gx;i++) grid[j*(gx+1)+i] = rnd();
      return {grid,gx,gy};
    }

    function sampleValueGrid(g, x, y){
      const gx = g.gx, gy = g.gy, grid = g.grid;
      // clamp inside
      if(x < 0) x = 0; if(y < 0) y = 0; if(x > gx-1) x = gx-1; if(y > gy-1) y = gy-1;
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi, yf = y - yi;
      const a = grid[yi*(gx+1) + xi];
      const b = grid[yi*(gx+1) + (xi+1)];
      const c = grid[(yi+1)*(gx+1) + xi];
      const d = grid[(yi+1)*(gx+1) + (xi+1)];
      const u = fade(xf), v = fade(yf);
      const lerp1 = lerp(a,b,u);
      const lerp2 = lerp(c,d,u);
      return lerp(lerp1, lerp2, v);
    }

    function fbm(nx, ny, octaves, persistence, seed){
      let value = 0, amplitude = 1, frequency = 1, max = 0;
      for(let o=0;o<octaves;o++){
        const gx = Math.ceil((nx * frequency) + 1);
        const gy = Math.ceil((ny * frequency) + 1);
        const grid = makeValueGrid(seed+"|"+o, gx, gy);
        value += sampleValueGrid(grid, nx*frequency, ny*frequency) * amplitude;
        max += amplitude;
        amplitude *= persistence;
        frequency *= 2;
      }
      return value / max;
    }

    function hashString(s){
      // simple string to 32-bit int hash
      let h = 2166136261 >>> 0;
      for(let i=0;i<s.length;i++){
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }

    // ---------- scene creation ----------
    const sceneEl = document.getElementById('scene');
    const seedEl = document.getElementById('seed');
    const scaleEl = document.getElementById('scale');
    const octEl = document.getElementById('octaves');
    const persEl = document.getElementById('persistence');
    const maxhEl = document.getElementById('maxh');
    const colsEl = document.getElementById('cols');
    const rowsEl = document.getElementById('rows');

    const scaleVal = document.getElementById('scaleVal');
    const octVal = document.getElementById('octVal');
    const persVal = document.getElementById('persVal');
    const maxhVal = document.getElementById('maxhVal');

    function applyRootVars(cols, rows, tile){
      document.documentElement.style.setProperty('--cols', cols);
      document.documentElement.style.setProperty('--rows', rows);
      document.documentElement.style.setProperty('--tile-size', tile+'px');
    }

    function generate(){
      const seed = seedEl.value || Date.now().toString();
      const scale = Number(scaleEl.value);
      const octaves = Number(octEl.value);
      const persistence = Number(persEl.value);
      const maxh = Number(maxhEl.value);
      const cols = Number(colsEl.value);
      const rows = Number(rowsEl.value);
      applyRootVars(cols, rows, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-size'))||14);

      sceneEl.innerHTML = '';
      // center offset, we'll place tiles so (0,0) is top-left
      const tileSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-size'));

      // Precompute heights
      const heights = new Float32Array(cols*rows);
      let min = Infinity, max = -Infinity;
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          const nx = x/scale, ny = y/scale;
          const h = fbm(nx, ny, octaves, persistence, seed);
          heights[y*cols + x] = h;
          if(h<min) min=h; if(h>max) max=h;
        }
      }
      // Normalize then create tiles
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          const raw = heights[y*cols + x];
          const norm = (raw - min) / (max - min + 1e-8);
          const mapped = Math.round(norm * maxh);
          const z = mapped * Number(getComputedStyle(document.documentElement).getPropertyValue('--layer-spacing'));

          const t = document.createElement('a');
          t.className = 'tile';
          t.style.width = tileSize + 'px';
          t.style.height = tileSize + 'px';
          // position
          const px = x * tileSize; const py = y * tileSize;
          t.style.transform = `translate3d(${px}px, ${py - mapped*2}px, ${z}px)`; // lift a bit by y for nicer silhouette

          // color: map height -> color gradient
          const col = colorForHeight(norm);
          t.style.background = `linear-gradient(180deg, ${col.top}, ${col.bot})`;
          t.style.setProperty('--x', x);
          t.style.setProperty('--y', y);
          sceneEl.appendChild(t);
        }
      }
      // resize viewport to match grid
      const viewport = document.querySelector('.viewport');
      viewport.style.width = (cols * tileSize) + 'px';
      viewport.style.height = (rows * tileSize) + 'px';
    }

    function colorForHeight(h){
      // simple gradient: deep water -> sand -> grass -> rock -> snow
      if(h < 0.35) {
        const deep = mixColor('#003055','#1a7bd7', h/0.35);
        return {top: lighten(deep,0.06), bot: deep};
      }
      if(h < 0.42){ // shore
        const sand = mixColor('#cdb78d', '#e6d5b3', (h-0.35)/0.07);
        return {top: sand, bot: '#b9976b'};
      }
      if(h < 0.7){
        const grass = mixColor('#2a8f3b','#669f5a', (h-0.42)/0.28);
        return {top: lighten(grass,0.05), bot: grass};
      }
      if(h < 0.88){
        const rock = mixColor('#7a7370','#5a5454', (h-0.7)/0.18);
        return {top: rock, bot: darken(rock,0.06)};
      }
      return {top:'#ffffff', bot:'#dfe9ea'}; // snow
    }

    // color helpers (tiny)
    function hexToRgb(hex){
      hex = hex.replace('#',''); if(hex.length===3) hex = hex.split('').map(s=>s+s).join('');
      const r = parseInt(hex.slice(0,2),16), g = parseInt(hex.slice(2,4),16), b = parseInt(hex.slice(4,6),16);
      return [r,g,b];
    }
    function rgbToHex(r,g,b){ return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
    function mixColor(a,b,t){ const A=hexToRgb(a), B=hexToRgb(b); return rgbToHex(Math.round(A[0]+(B[0]-A[0])*t), Math.round(A[1]+(B[1]-A[1])*t), Math.round(A[2]+(B[2]-A[2])*t)); }
    function lighten(hex, amt){ const c=hexToRgb(hex); return rgbToHex(Math.min(255,Math.round(c[0]+255*amt)),Math.min(255,Math.round(c[1]+255*amt)),Math.min(255,Math.round(c[2]+255*amt))); }
    function darken(hex, amt){ const c=hexToRgb(hex); return rgbToHex(Math.max(0,Math.round(c[0]-255*amt)),Math.max(0,Math.round(c[1]-255*amt)),Math.max(0,Math.round(c[2]-255*amt))); }

    // ---------- UI wiring ----------
    document.getElementById('regen').addEventListener('click', generate);
    document.getElementById('randomize').addEventListener('click', ()=>{ seedEl.value = Math.floor(Math.random()*1e9).toString(); generate(); });

    scaleEl.addEventListener('input', ()=> scaleVal.textContent = scaleEl.value);
    octEl.addEventListener('input', ()=> octVal.textContent = octEl.value);
    persEl.addEventListener('input', ()=> persVal.textContent = persEl.value);
    maxhEl.addEventListener('input', ()=> maxhVal.textContent = maxhEl.value);

    // drag to rotate scene
    (function addDrag(){
      let dragging=false, ox=0, oy=0;
      const s = document.querySelector('.scene');
      document.querySelector('.viewport').addEventListener('pointerdown', (e)=>{dragging=true; ox=e.clientX; oy=e.clientY; e.target.setPointerCapture&&e.target.setPointerCapture(e.pointerId);});
      window.addEventListener('pointerup', ()=> dragging=false);
      window.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dx = e.clientX - ox, dy = e.clientY - oy; ox = e.clientX; oy = e.clientY; const curX = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scene-rotate-x')) || 55; const curY = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scene-rotate-y')) || -10; document.documentElement.style.setProperty('--scene-rotate-x', (curX - dy*0.15) + 'deg'); document.documentElement.style.setProperty('--scene-rotate-y', (curY + dx*0.12) + 'deg'); });
    })();

    // export (download) single-file HTML
    document.getElementById('export').addEventListener('click', ()=>{
      const html = `<!doctype html>\n` + document.documentElement.outerHTML;
      const blob = new Blob([html], {type:'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'css-terrain.html'; a.click(); URL.revokeObjectURL(url);
    });

    // kick off
    generate();
  </script>
</body>
</html>
